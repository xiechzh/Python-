# Python-留学生校招面试面经

后端开发---Python
【可变对象&不可变对象】	17
【变量】	17
【内存回收机制】	18
【线程 & 进程】process thread	18
【Python是什么语言】	20
【迭代器 & 生成器】iterator & generator	21
【装饰器】	22
【元类 metaclass】	22
【字符串】	22
【获取当前日期】	22
【解释器/线程安全】	23
【GIL/线程安全】解释器CPython	23
【xrange 和range区别】	23
【列举几个标准异类】	23
【类型转换有哪些】	23
【List】	24
【函数】	24

【可变对象&不可变对象】
【变量】
【内存回收机制】
【线程 进程】
       进程线程的区别 / 进程间通信 / 线程安全/GIL / 线程中join（）命令
【Python是什么语言】
【迭代器& 生成器】--- iterator generator
【装饰器】 //
【元类metaclass】
【字符串】
【获取当前日期】
【解释器/线程安全】
【GIL/线程安全】CPython
【xrange 和 range】
【列举几个标准异常类】
【类型转换有哪些】
【list】
【函数】help() 和dir()区别   |   __new__() 和__init__()区别
【RestFul API】
 
 

【可变对象&不可变对象】
定义： 不可变immutable对象：变量的值不允许被改变，当变量改变时，实际上是把原来的复制一份以后再改变，开辟一个新的地址，a指向这个新的地址（前后id不一样），原来a对应的值因为不再有对象指向它，就会被垃圾回收。   可变mutable对象：对象指向的内存中的值会改变，更改这个变量时，还是指向原来内存中的值，并且进行原地修改，不开辟新的内存。对a进行操作不会改变a的地址值，改变前后id不变。
python中，数值类型int、float、字符串str、tuple、boole都是不可变对象。
列表list、集合set、字典dict、bytearray都是可变对象。
不可变量对象的内部实现
int类型：较小的整数会很频繁的被使用，所以python将这些对象放置到了一个池子里，每次需要这些对象的时候就到池子中获取这个值，避免多次的重复repeated创建对象引起的许多不必要的开销。这个池子内的数字范围是[-5，257)，所以都是从池子里面取值，id不变。Float类型：对于float类型的使用自然没有int那么频繁，也就没有池子给到这个类型，所以每次重新创建，值一样的变量id也不一样，值变化id就变化。Tuple类似。String类型：str由于被重复使用的概率比较大，所以在python中为单词类型的str做了一个缓存，也就是说如果是单词类型的str，会被存储到一个字典dict中，字典的内容就是字符串为key，地址为value。当有一个字符串需要创建，就先去访问这个字典，如果存在则返回字典中字符串的地址，如果不存在，则返回新创建的地址，并将这个字符串添加进入字典。这是字符串的intern机制。

【变量】
概念：Python中的变量都是指针。所以所有的变量无类型限制，可以指向任意对象。指针的内存空间大小是与类型无关的，其内存空间只是保存了所指向数据的内存地址。Python的所有变量其实都是指向内存中的对象的一个指针。

【内存回收机制】
python 使用的内存回收机制是计数器回收，就是每块内存上有一个计数器，表示当前有多少个对象指向该内存，每当一个变量不再使用时，就让该计数器-1，有新对象指向该内存时就让计数器+1，当计数器为0时，就可以收回这块内存了。

【线程 & 进程】process thread
 
什么是进程
进程是程序的一次执行过程，是一个动态的，是程序在执行过程中分配和管理资源的基本单位，由程序、数据集合和进程控制三部分组成。每一个进程都有一个自己的地址空间，至少有5种基本状态「初始态，执行态，等待状态，就需状态，终止状态」。
什么是线程
线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源（文件描述符、全局变量、堆空间）。「新建，就绪，运行，死亡」
进程线程的关联和区别
线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以拥有多个线程，但至少有一个线程。|  根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。开销方面：进程的切换比线程切换开销大。每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销。线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。所处环境：在操作系统中能同时运行多个进程（程序），而同一个进程中可以同时执行多个线程，但是每个时间片中只有一个线程执行。在内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间，线程的话，除CPU外，系统不会为线程分配内存，线程组之间只能共享资源。进程可以看作独立应用，线程不可以。通信：线程之间通信更方便，同一进程下的线程共享全局变量、静态变量等数据，进程间通信比较麻烦。多进程更强壮：多进程时一个进程死掉并不会对另外一个进程造成影响，因为进程有自己的独立地址空间。而多线程只要有一个线程死掉，整个进程也死掉了。

进程间通信IPC/同步synchronized方式
1.通信：管道 | FIFO | 消息队列 | 信号 | 共享内存 | socket | stream流
 线程中通信/同步方式
1.通信：同一进程的线程共享资源。 2. 同步：互斥锁 | 递归锁 | 条件变量 | 信号量
Python中进程间通信
python 提供了多种进程间通信的方式，其中以Queue和Pipe用得最多。进程间通信是每个进程是相互独立的，都有自己的地址空间，任何一个进程看不到另一个进程的全局变量，所以进程间的数据交换必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷贝到内核缓冲区，进程B再从内核空间拷贝走，内核提供的这种机制称为进程间通信。
通过Queue通信
Queue是一种多进程安全的队列。有俩种通信方法，get() 用于向队列中加入数据，有俩个属性blocked和timeout。put() 用于从队列中获取一个数据并将其从队列中删除，同样有blocked和timeout俩个属性。通过Pipe通行：Pipe与Queue不同之处在于Pipe是用于俩个进程之间的通信。

什么是线程安全
多线程时，可能会发生多个线程同时对一个公共资源进行操作的情况，就会发生混乱。线程锁就是为了避免这种混乱，只有一个线程能处于上锁状态，当一个线程上锁之后，如果另一个线程试图获得锁，该线程就会被挂起直到拥有锁的线程将锁释放。优点：锁确保某段关键代码只能由一个线程从头到尾执行，保证了数据的唯一性。缺点：阻止了多线程并发执行，效率降低。由于存在多个锁，不同的线程持有不同锁并试图获取对方的锁的时候，可能会造成死锁。     
怎么控制线程
没有办法认为控制线程，因为线程是系统控制的。但可以用一些方式来影响线程的调用，比如互斥锁mutex，sleep（阻赛），死锁。互斥锁只有两种状态，lock 和 unlock。
 GIL锁 / 数据安全 | 内存泄漏 | 死锁
python中GIL（Global Interpreter Lock），是python解释器Cpython中为了保证数据安全所实现的一种锁。不管进程中有多少线程，只有拿到了GIL锁的线程才可以在CPU上运行，即使是多核处理器。因而，对于CPU密集型的线程，效率比较低。Python多线程比较适用于IO密集型的程序。
读写锁（同步），自旋锁（同步），信号量（同步与互斥）
内存泄漏  死锁 是怎么导致的？这个锁是必要的，因为CPython的内存管理不是线程安全的。当多个线程同时修改计数器值时，可能导致内存泄漏，使用锁来解决这个问题，有时可能会添加多把锁，就会导致另一个问题，死锁。
怎么避免内存泄漏  死锁 问题？为了避免内存泄漏和死锁问题，CPython使用单锁，即GIL，执行python字节码都需要获取GIL，这可以防止死锁，
影响：GIL适用于I/O绑定多线程程序，因为线程在等待I/O时共享锁。
          GIL不适合及酸性绑定多线程程序。例如，使用线程处理部分图像的程序，不仅会因锁定而
          成为单线程，而且会增加执行时间，这种增加是由锁的获取和释放开销的结果。
怎么解决死锁
资源一次性分配 | 资源有序分配 | GIL

多线程 or 多进程
 CPU密集型 -多进程并行执行，程序需要占用CPU进行大量运算和数据处理。I/O密集型：多线程，因为python多线程不是并行执行，而程序需要频繁的进行I/O操作。

为什么需要设置线程？设置线程的原因
 
设置线程的好处？并发、隔离
涉及到OS的俩个重要概念：并发和隔离
线程和并发有关系，进程和隔离有关系。
并发：是为了尽量让用硬件利用率高，线程是为了在系统层面做到并发。线程上下文切换效率比进程上下文切换效率高很多，这样可以提供并发效率。
隔离：也是并发之后要解决的重要问题，计算机的资源一般是共享的，隔离要能保证崩溃的资源能够被回收，不影响其他代码的使用。所以说一个操作系统只有线程没有进程也是可以的，只是这样的系统会经常崩溃。
Python中多进程更能发挥多核并发的利用率（不太明白为什么）
线程的属性
 current_thread() 返回当前线程对象，main_thread() 返回主线程对象， active_count() 当前处于alive状态的线程数，enumerate() 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程，get_ident() 返回当前线程的ID
 线程中的join()命令，deamon守护线程命令：
可以通过join方法让主线程阻塞，等待其创建的线程执行完成。如果不加任何限制，当主线程执行完毕之后，当前程序并不会结束，必须等到所有线程都结束之后才能结束当前进程。   可以通过将创建的线程指定为守护线程daemon，这样主线程执行完毕之后会立即结束未执行完的线程，然后结束程序。

引申 / 计算机组成原理
电脑由CPU+RAM+各种资源（显卡，光驱，键盘等外设等）组成。一个进程的执行包含 CPU加载上下文+CPU执行+CPU保存上下文。
多进程：Python允许多进程（multiprocessing），进程的创建是需要时间的，需要创建多个进程时，可以使用multiprocessing中的Pool类开进程池。

一个进程至少有一个线程。进程由程序，数据集合和进程控制块3部分组成。线程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。


【Python是什么语言】
python是一种跨平台的面向对象的语言，最初被设计用于编写shell脚本。语法简单，大量的库，开发周期短（代码量小），代码规范易读，可扩张型强。缺点：在执行性能方面有所欠缺，不如Java稳定和扩展性强。
Python语言的特点
封装，继承，多态。封装 – 隐藏对象的属性和实现细节，仅对外提供公共访问方式 | 继承 – 是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类 | 多态 – 一种事务的多种体现形式，函数的重写就是多态的一种体现。

【迭代器 & 生成器】iterator & generator
什么是迭代器 
 是访问集合元素的一种方式，是可以记住遍历的位置的对象，访问的时候从第一个元素到最后一个，只会往前不会退后。有俩个基本的方法 --- iter() next()。
@  类都有一个构造函数，Python的构造函数为__init__()，它会在对象初始化的时候执行。
List、tuple、dict、string都是可迭代对象。Number、bool都是不可迭代的。
迭代器使用场景
斐波那契数列
什么是异常StopIteration
异常用于标志迭代的完成，防止出现无限循环的情况。在__next__()方法中我们可以设置在完成指定循环次数后出发StopIteration异常来结束迭代
Coding：创建一个返回数字的迭代器
创建一个返回数字的迭代器，初始值为1，逐步递增2
 

生成器：在python中，使用了yield的函数被称为生成器（generator）。生成器是一个返回迭代器的函数,，只能用于迭代操作，返回的是一个迭代器对象，可以理解为生成器就是一个迭代器。可以节省大量空间。
在调用生成器运行的过程中，每次遇到yield时函数时会暂停并保存当前所有的运行信息，返回一个yield值，并在下一次执行next()方法时从当前位置继续运行。
Coding: 使用yield实现斐波那契数列
 


生成器表达式
可以认为是一种特殊的生成器函数。和生成器一样，生成器表达式也是返回生成器generator对象，一次之返回一个值。
 

【装饰器】
--- 

【元类 metaclass】
 Python 中所有东西都是对象，他们都是从一个类创建而来，创建元类都是type。元类的主要目的是为了当创建类时能够自动的改变类。它可以拦截类的创建 - 修改类 - 放回修改之后的类。
类也是对象，拥有创建对象的能力，可以进行如下操作：赋值给一个变量，copy它，为它增加属性，将它作为函数参数进行传递。

【字符串】
字符串大小写转换：str.upper() str.lower()  str.capitalize() #把第一个字母转化为大写字母
                     str.title() #把每个单词的第一个字母转化为大写，其余小写
字符串格式化：主要有俩种方式，占位符(%)和format方式

【获取当前日期】
import datetime 
当前时间： Now_time = datetime.datetime.now()
格式化成想要的日期：如“2020-03-08”datetime.datetime.now().strftime(‘%Y-%m-%d’)
在当前时间增加1小时：add_hour= datetime.datetime.now()+datetime.timedelta(hours=1)

【解释器/线程安全】
什么是解释器
解释器将我们的python代码翻译为机器指令语言，（解释器）本身也是个程序。（是解释python代码的，计算机智能识别机器指令语言也就是01）。
•	CPython：官方默认版本，使用C语言开发，是python使用最广泛的解释器，有GIL。
•	Ipython：基于CPython之上的交互式解释器，其他方面和CPython相同。有GIL。
•	PyPy：采用JIT（just in time）也就是即时编译器， 对python代码执行动态编译，目的是加快执行速度，有GIL。绝大部分python代码都可以在PyPy下运行，但是执行结果可能不同。
•	Jython：运行在Java 平台上的解释器，把python代码编译为Java字节码执行，没有GIL。
•	IronPython：和Jython类似，只不过IronPythohn运行在微软.Net平台上的python解释器，没有GIL。

 【GIL/线程安全】解释器CPython
python中GIL（Global Interpreter Lock），是python解释器Cpython中为了保证数据安全所实现的一种锁。不管进程中有多少线程，只有拿到了GIL锁的线程才可以在CPU上运行，即使是多核处理器。因而，对于CPU密集型的线程，效率比较低。Python多线程比较适用于IO密集型的程序。
GIL是Cpython解释器遗留下来的，因为研发之处并没有想到后来多线程的发展趋势，它是很容易可以移除的，但是移除以后，会出现线程安全问题，解决线程安全问题后发现效率还没有GIL锁下运行的效率高。因而，在python下，想要实现并发，多线程不好用，可以用多进程。
在GIL下，多线程对cpu的利用不如多进程，也就是多进程的代码可能运行时间还快一些。
读写锁（同步），自旋锁（同步），信号量（同步与互斥）
内存泄漏  死锁 是怎么导致的？这个锁是必要的，因为CPython的内存管理不是线程安全的。当多个线程同时修改计数器值时，可能导致内存泄漏，使用锁来解决这个问题，有时可能会添加多把锁，就会导致另一个问题，死锁。
怎么避免内存泄漏  死锁 问题？为了避免内存泄漏和死锁问题，CPython使用单锁，即GIL，执行python字节码都需要获取GIL，这可以防止死锁，
影响：GIL适用于I/O绑定多线程程序，因为线程在等待I/O时共享锁。
          GIL不适合及酸性绑定多线程程序。例如，使用线程处理部分图像的程序，不仅会因锁定而
          成为单线程，而且会增加执行时间，这种增加是由锁的获取和释放开销的结果。
怎么解决死锁
资源一次性分配 | 资源有序分配 | GIL

【xrange 和range区别】
 python3中没有xrange，只有range。range()返回的是一个list 对象，xrange()返回的是一个生成器对象。

【列举几个标准异类】
BaseException, SystemExit解释器请求退出，Exception, StopIteration, OverflowError数值运算超出最大限制，

【类型转换有哪些】
int(x),  long(x),  float(x),  str(x),  list(x),  set(x),  tuple(x)  |  chr(x) 整数 => 字符  |  ord(x) 字符=>它的整数值  | hex(x) 整数=>十六进制字符串  |  oct(x)整数=>八进制字符串

【List】
删除list里面重复的元素
•	Set()
•	先把list重新排序，然后从list的最后开始扫描
•	使用字典函数，把list里的元素变成字典的key，再print key
•	append方式，新建一个list_2，重新list_2.append i for i not in list_1

list 和 tuple 区别
List长度可变化，tuple不可以  |  list中元素的值可以改变，tuple不能改变   |   list支持append insert remove pop等方法，tuple不支持

创建矩阵
 

【函数】
help() 和dir()区别 
help() – 用于显示文档字符串，还可以查看与模块，关键字，属性等相关的使用信息。
dir() – 可以列出制定类或模块包含的全部内容（包括函数、方法、类、变量等）。

__new__() 和__init__()区别

【Pandas】
Series

DataFrame:
是表格型数据结构，包含一组有序的列，每列可以是不同的值类型。DataFrame有hang
Pandas怎么合并数据？
合并数据data1，data2，data3
竖着添加，axis=0:  
 
横向添加，join合并，axis=1:
 
Append添加：
 


【RestFul API】
市面上有多种风格的Web API，最流行最容易访问的一种是Restful API



 
后端开发---算法
【二分查找算法】--- Bisearch	27
【冒泡排序】--- Bubble Sort	27
【快速排序】	27
【选择排序】--- Selection Sort	28
【维特比算法】	28
【逻辑回归】	28
【二叉树遍历算法】--- 前序遍历为例	29
【堆排序】	29
【下一个排序】	30
【排序算法的时间空间复杂度】
 
 
【二分查找算法】--- Bisearch
使用二分元素必须是有序排列的，搜索过程从数组的中间元素开始，如果元素正好是要查找的元素，搜索过程结束。如果target >中间元素，则在>中间元素的那一半中查找，反之同样。
应用：适于待搜索的集合是相对静态的数据集。由于依赖于一个有序的集合，处理频繁插入和删除操作的数据集时不太高效。

【冒泡排序】--- Bubble Sort
冒泡排序重复地走访要排序的数列，一次比较俩个元素，如果他的顺序错误就把他们交换过来，这样每次能把最大的元素排到最后一位。然后重复直到没有再需要交换，也就是该数列已经排序完成。
算法描述：
1.	比较相邻的元素。如果第一个比第二个大，就交换他们俩个。
2.	对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。
3.	针对所有的元素重复以上的步骤，除了最后一个。
4.	重复1～3，直到排序完成。




【快速排序】
基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这俩部分记录继续进行排序（递归），以达到整个序列有序。
算法描述：
1.	从数列中挑出一个元素，作为“基准”pivot。（可以选第一个元素）
2.	重新排序数列，小的放基准左边，大的放右边，（这个操作称为分区partition）
3.	递归的recursive把左右俩个子数列排序
---coding
 

【选择排序】--- Selection Sort
选择排序是新建一个序列，从没有排序的序列里每次找到最大/小的元素，存放到新建序列，这样经过n-1趟，排血就完成了。
选择排序是表现最稳定的排序算法之一，因为无论什么时候数据进去都是O(n^2)的时间复杂度，所以数据规模越小越好。唯一的优点是不占用额外的内存空间。
算法描述：
首先在未排序序列中找到最小/大的元素，存放在排序序列的起始位置，然后剩余未排序元素中继续寻找最小/大元素。以此类推。N个元素的可经过n-1趟选择排序得到有序结果。
1.	初始状态：无序区为R[1…n], 有序区空
2.	第i趟排序开始时，无序区R[i…n],有序区R[1…i-1]。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第一个记录R[1]交换。之后更新无序区为R[i+1…n]，有序区为R[1…i]
3.	N-1趟结束，数组有序化了

【维特比算法】
维特比算法是一个特殊的应用很广的动态规划算法。

【逻辑回归】
--- logistic regression 是分类模型，常用于二分类
Sigmoid函数是Logistic的分布函数在u=0，r=1的特殊形式。
【聚类分析kmeans】
项目用的是基于非层次的kmeans聚类，距离根据均值（或者欧式距离）计算。

Kmeans算法计算步骤：
取得k个初始质心：随机抽取k个点作为初始聚类的中心，来代表各个类
把每个点划分进相对应的类：根据欧式距离最小原则，把每个点划分进最近的类
重新计算质心：根据均值等方法，重新计算每个类的质心
迭代计算质心：迭代2，3步
聚类完成：聚类中心不再发生移动

Kmeans聚类de特点：
简单、直观。探索性的分析，分类是未知的。异常值和特殊的变量对聚类有较大影响

Kmeans聚类有什么作用：
聚类分析可以应用在数据预处理过程中，多维数据可以通过聚类分析的方法进行聚集。还可以用来发现数据项之间的依赖关系。在商业上，聚类分析可以细分市场，用来发现不同的客户群，并且通过对不同的客户群的特征的刻画，来研究消费者行为。在电子商务上，聚类分析

【二叉树遍历算法】--- 前序遍历为例
Coding_1：用递归
 
Coding_2：用栈迭代
 


【堆排序】
时间复杂度（最坏最好都是）O(nlogn)。空间复杂度时O(1)。不稳定
•	先把数组生成一个最大堆heapify
•	然后把root和最后一个元素交换
•	砍断最后一个元素（也就是原root），就得到了最大的一个元素
•	把剩下的n-1个元素恢复成堆
•	重复前3步操作



【下一个排序】
   


【DFS，BFS】
【DFS，BFS】--- DFS深度优先搜索（适合？），BFS广度优先搜索（适合最小路径）
DFS depth first search深度优先搜索：
图算法的一种，过程简要来说是对每一个可能的分支路径深入到不能再深入为止，并且每个节点只能访问一次。
使用stack来实现：
•	把根节点压入栈中
•	每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中，并把这个元素记为它下一级元素的前驱
•	找到所有要找的元素时结束程序。如果遍历整个树还没有找到，结束程序。

BFS breadth first search广度优先搜索：
最简单的图搜索算法之一，并不考虑结果的可能位置，彻底的搜索整张图，直到找到结果为止。
使用queue来实现：
•	把根节点放在队列的末尾
•	每次从队列的头部取出一个元素，查看它所有的下一级的元素，把这些元素放到队列的末尾，并把这个元素记为它下一级元素的前驱
•	找到所有要找的元素时结束程序。如果遍历整个树还没有找到，结束程序。


 
后端开发---数据结构
【 MongoDB & MySQL】	33
【链表】	36
【堆Heap】--- 存取随意	37
【栈Stack】--- 后进先出	37
【队列Queue】--- 先进先出	38
【双端队列Deque】	38
【树Tree】	38

 

【 MongoDB & MySQL】
什么是MongoDB
MongoDB是一个基于分布式文件存储 [1]  的数据库。由C++语言编写。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。特点：高性能，易部署，易使用。模式自由（schema-free）。不适用：传统的商业智能应用/复杂的跨文档级联查询
MongoDB和传统SQL区别
主要区别是传统的SQL每条数据有固定的scheme，不能混传，必须要按照他的格式来，而mangoDB就比较自由，音频和文字可以放在同一条。传统SQL优点：事务管理，比如如果用户正在使用过程中突然断网，系统会将正在使用的回滚，规范性更好，所以现在银行很多还是使用传统SQL系统。
MySQL 索引
的存储类型有俩种，Btree、Hash，就是用树或者Hash值来存储该字段。索引是在存储引擎中实现的，不同存储引擎，会使用不同的索引。MySQL提供多种储存引擎，（有pluggable storage engine architecture的特性）。
优点：大大提高MySQL的检索速度  | MySql所有列类型都可以被索引
缺点：增加了创建表的时间 | 同时会降低更新表的速度，比如进行insert、update、delete都会变慢，因为更新时，MySQL在保存数据的同时还要保存索引文件 | 索引需要占空间 
不适用场景：数据量小->最好不用，因为可能不会产生优化效果 | 在同一值少的列上不要建立索引，比如学生表的“性别”。

事务的概念和特性
概念：事务主要用于处理操作量大，复杂度高的数据。（比如，在人员管理系统中，删除一个人员的时候，需要删除人员的基本资料，还要删除该人员的相关信息，比如信箱，文章等等，这样，这些数据库操作语句就构成一个事务）。
在MySQL中只有使用了Innodb数据库引擎的数据库或者表才支持事务。
特性（ACID）：
原子性（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；
一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，读未提交Read uncommitted、读提交Read Committed、可重复读Repeatable Read 和串行化Serializable。
持久性（Durability）：一旦事务提交成功，对数据的修改是永久性的，即便系统故障也不会丢失。

会出现哪些并发一致性问题？//待整理
丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
脏读（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；
不可重复读（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（可能被更新或删除了）；
幻读（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）

数据库的四种隔离级别？
SQL定义了四种隔离级别，指定了哪些数据改变其他事务可见，哪些改变其他事务不可见。低级别的隔离可支持更高的并发处理，同时占用的资源更少。
•	未提交读（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；
•	提交读（Read Committed）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；会有不可重复读问题，（eg，开启AB两个事务，在B事务更新并提交后，A事务读取了更新后的数据。这样处于同一A事务中查询出现了不同的查询结果，即不可重复读现象）。
•	可重复读（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；     理论上会导致幻读。InnoDB和Falcon储存引擎通过多版本并发控制解决了该问题：InnoDB通过给每个数据添加俩个隐含值的方式来实现。2个隐含值记录了行的创建时间，以及过期时间。
•	可串行化（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。
 

储存引擎种类：
 
// 待整理
 
•	MyISAM引擎：又可以分为静态MyISAM，动态MyISAM 和压缩MyISAM三种。
1.	静态MyISAM：如果数据表中的各项数据列的长度都是预先固定好的，服务器将自动选择这种表类型。由于表中每条记录所占用的空间一样，这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。
2.	动态MyISAM：如果数据表中出现varchar、xxxtext、xxxBLOB字段时，服务器将自动选择这种表类型。相比较而言，这种表的数据可能离散的储存在内存中，因而执行效率下降，内存中可能会出现很多碎片。
3.	压缩MyISAM：进一步减小了占用的储存，但是压缩后表不能再被修改。
MyISAM引擎适用于：选择密集型的表，插入密集型的表。MyISAM在筛选大量数据时非常迅速，而且并发插入特性允许同时选择和插入数据。
MyISAM表是独立于操作系统的，因而可以轻松的将其从windows服务器移植到Linux服务器。每建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件名（表名），比如一个test表，会生成test.frm储存表定义、test.MYD储存数据、test.MYI储存索引。
•	InnoDB 引擎：这个表类可以看作是对MyISAM的进一步更新的产品，提供了事务、行级锁机制和外键约束的功能。它的表需要更多的内存和储存，会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。适用于：
1.	奉新密集的表 – InnoDB特别合适处理多重并发的更新请求
2.	事务 – InnoDB是支持食物的标准MySQL储存引擎
3.	自动灾难恢复–与其他储存引擎不同，InnoDB表能够自动从灾难中恢复
4.	外键约束 – MySQL支持外键的储存引擎只有InnoDB
5.	支持自动增加列AUTO_INCREMENT属性

索引结构（算法）：常用储存引擎对应的索引结构
 
Mysql中国呢常用俩种索引结构（算法）BTree 和 Hash，两种算法检索方式不一样，对查询的作用也不一样。
•	Hash索引：不能使用范围查询 | 不能利用部分索引键查询 | 无法避免数据的排序操作 | 遇到大量hash值相等的情况后性能可能不如BTree高
•	BTree：

使用B树和B+树的比较 //待整理
InnoDB的索引使用的是B+树实现，B+树对比B树的好处：
•	IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；
•	范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；
•	查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多

创建索引：
  
删除索引：
 
使用ALTER命令添加和删除索引。
 

--- noSQL 


【链表】
链表和数组的区别：1.数组静态分配内存，链表动态分布内存。2.数组在内存中是连续的，链表是不连续的  3.数组利用下标定位，查找时间复杂度是O(1)，链表通过遍历定位元素，查找的时间复杂度是O(n)。4.数组插入和删除需要移动其他元素，时间复杂度是O(N)，链表插入和删除不需要移动其他元素，时间复杂度是O(1)。
链表的优点
1.插入和删除的效率高，只需要改变指针的指向就可以进行插入和删除。2.内存利用率高，不会浪费内存，可以使用内存中细小的不连续的空间，只有在需要的时候才去创造空间。大小不固定，拓展很灵活。缺点：查找率低。
单链表双链表区别
单链表的每一个节点中只有指向下一个节点的指针，不能进行回溯，适用于节点的增加和删除。双链表的每一个节点给中既有志向下一个节点的指针，也有指向上一个节点的指针，可以快速的找到当前节点的前一个节点，适用于需要双向查找的节点值的情况。
双链表相对于单链表的优点
删除单链表中的某个节点时，一定要得到待删除节点的前驱，得到其前驱的方法一般是在定位待删除节点的时候一路保存当前节点的前驱，这样指针的总的的移动操作为2n次，如果是用双链表，就不需要去定位前驱，所以指针的总的的移动操作为n次。
查找时也是一样的，可以用二分法的思路，从头节点向后和尾节点向前同时进行，这样效率也可以提高一倍，但是为什么市场上对于单链表的使用要超过双链表呢？从存储结构来看，每一个双链表的节点都比单链表的节点多一个指针，如果长度是n，就需要n*lenght（32位是4字节，64位是8字节）的空间，这在一些追求时间效率不高的应用下就不适用了，因为他占的空间大于单链表的1/3，所以设计者就会一时间换空间。
判断链表是否有环
1.穷举遍历。从头节点开始，依次遍历单链表的每一个节点。当遍历到新节点时，就从头重新遍历之前的所有节点，和新节点进行比较，看新节点是否已经存在。已存在，说明有环。重复到没有新节点。          有环的情况下，假设从链表头节点到入环点距离D，环长S，时间复杂度：(D+S-1)*(D+S）/2，也就是O(N*N)，空间复杂度：O(1)。          2.哈希表缓存：雷同穷举，不同的是创建一个以节点ID为键的HashSet集合，来存储遍历过的节点。这样算法的时间复杂度减小：D+S，空间复杂度增加：O(N)       3.快慢指针：创建俩个指针1和2同时指向头节点。然后开始一个大循环，让指针1每次向下移动一个节点，指针2每次向下移动2个节点，比较指向的这俩个节点是否相同。若相同，有环。若不同，继续下一次循环。
判断俩个单链表是否相交，以及相交点：

【堆Heap】--- （存取随意）可以被看作一颗完全二叉树
存取随意，堆是一种经过排序的树形数据结构，每个节点都有一个值。
大顶堆 ： 每个结点的值都大于等于其左右孩子结点的值，称为大顶堆；
小顶堆 ： 每个结点的值都小于等于其左右孩子结点的值，称为小顶堆；
堆常用来实现优先队列。支持堆排序。快速找出一个集合中的最大/小值
Import heapq
属性： heap = []
heapq.heappush(heap, item)
heapq.heappop(heap)
heapq.nlargest(n, iterable, key=None)
heapq.nsmallest(n, iterable, key=None)
heapq.heapify(x)  将数组x转换为堆

堆和普通树的区别：
节点的顺序。二叉搜索树种，左子节点必须比父节点小，右子节点必须比父节点大。堆不是，最大堆中，只需两个子节点都必须比父节点小。
内存占用小，比普通树占用的空间少
搜索。堆中搜索很慢
 
堆的数组是： [10, 7, 2, 5, 1]
堆插入：
•	将插入元素插入到数组的尾部。
•	检查是否所有父节点都比左右子节点大，若不是，交换父子节点，冒泡
堆删除根节点：
•	删除根节点后，root为空节点了，把数组尾部的元素放到根节点
•	进行堆属性修复，shiftUp()   shiftDown(), 保证父节点大于左右子节点
大部分时候需要删除的是根节点，如果要删除其他节点，同，先将要删除的节点和尾节点交换，再恢复堆

堆化：
从h-1层开始检查，检查每个父节点是否大于俩个字节点，一层层往上，直到root。保证每个父节点都比左右子节点大。

【栈Stack】--- 后进先出
后进先出。可以用一个单链表来实现栈。
栈一般只对栈顶进行插入删除结构
用到栈的情况：只关心上一次的操作 | 处理完上一次操作后，能在O(1)时间内查找到更前一步的操作 
栈和堆的区别（内存上）：栈内存储存的是局部变量而堆内存是实体 / 栈内存的更新速度高于堆内存 / 栈内存的生命周期一结束就会被释放而堆内存会被垃圾回收机制不定时回收 / 栈的内存空间是系统自动分配自动回收的，堆是程序员根据需要自己申请的空间。
栈的顺序存储结构（大部分栈）实例：
二进制数转换为10进制数
括号配对
栈的链式存储结构实例：
数学运算式

【队列Queue】--- 先进先出
先进先出。有头指针和尾指针的链表就能实现。
使用情况：当需要按照一定顺序处理数据的时候 | 数据的长度不断变化的时候
只允许在一端进行插入操作，在另一端进行删除操作的线性表。既可以用链表实现，也可以用顺序表实现。
实例：输入缓冲区接受键盘的输入

【双端队列Deque】
可以利用一个双链表来实现。队列的头尾俩端能在O(1)的时间内进行数据的查看、添加和删除。
使用情况：是下一个长度动态变化的窗口或者连续空间

【树Tree】
什么是树：树是n个节点的有限集。有且仅有一个特定的根节点root。n>0时root是唯一的，子树的个数没有限制，但他们一定是互不相交的。
度：节点拥有的子树树木称为节点的度
层：从上到下数，跟节点为第一层

什么是二叉树
特点：每个节点最多有两颗子树，也就是度<=2  |  左子树和右子树的次序不能颠倒  |  即使书中某节点只有一颗子树，也要区分是左子树还是右子树
存储结构：顺序存储（数组）：二叉树的顺序存储结构就是使用一位数组存储二叉树中的节点，并且节点的存储位置，就是数组的下标索引。（当二叉树是完全二叉树时，节点数刚好填满数组），适用于完全二叉树  |  二叉链表：用链表存储

什么是完全二叉树
所有节点完全按照先左孩子后右孩子的顺序插入，树的结构从左到右没有空缺的。（当有子节点的时候不要求一定要有右节点）。

特点：叶子节点只能出现在最下层和次下层  |  最下层的叶子节点集中在树的左部  |  如果节点度为1，则该节点只有左孩子，没有右孩子  |  同样节点的二叉树，完全二叉树深度最小
性质：具有n个节点的完全二叉树的深度为 ，其中log是向下取整的  

平衡二叉树 / AVL：balanced binary Tree 又称AVL树。
特点：是一颗空树，或它的左右两颗子树的高度差绝对值不超过1，并且左右两颗子树都是一颗平衡二叉树。

红黑树red black tree
是一种自平衡的二叉查找树，（计算机中用到的一种数据结构），
特点：每个节点或是黑色，或是红色  |  根节点是黑色  |  每个叶子结点是黑色  |  当一个节点是红色的时候，它的子节点必须是黑色  |  从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点
和其他二叉查找树类似，都是在进行插入和删除操作是通过特定操作保持二叉查找树的性质，从而获得较高的查找性能。时间复杂度O(logN)
应用场景：用来储存有序的数据，效率非常高，典型的用途是实现关联数组。
基本操作：插入和删除。通过左旋、右旋来继续保持红黑树的特性。
   
（左旋，意味着被旋转的节点将变成一个左节点。右旋，意味着被旋转的节点将变成一个右节点。）
插入：
二叉树遍历
指从二叉树根节点出发，按照某种次序依次访问二叉树中的所有节点，使得每个节点被访问一次，且仅被访问一次。
访问次讯可分为四种：前序遍历Preorder Traversal | 中序遍历Inorder Traversal | 后序遍历Postorder Traversal | 层序遍历
都是从根节点出发，先左后右，前序是第一次到达时输出，父节点->左子树->右子树 |  中序时第二次到达的时候输出，左->父节点->右 | 后序是第三次到达的时候输出，左->右->父节点
🌟🌟已知前序+中序，或者中序+后序遍历，可以确定一颗二叉树。前序+后序 不能确定一颗二叉树。

Coding_1：用递归
 
Coding_2：用栈迭代
 

自平衡二叉搜索树
二叉树搜索



【区块链】--- 
区块链blockchain
信息技术领域的术语。本质上是一个共享数据库，存储于其中的数据或信息，具有“不可伪造” “全程留痕”“可以追溯”“公开通明”“集体维护”等特征。
区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。
公有区块链public block chains：
联合区块链comsortium block chains：
私有区块链 private block chains：


 
后端开发---HTTP与计算机传输协议
【三次握手四次挥手机制及原因】three times handshake。	42
【TCP协议分层管理】	43
【GET和POST区别】	44
【cookie和session区别】	45
【HTTP HTTPS】	45
【Python中HTTP常见响应状态码】	45
【TCP UDP区别】	45
 
 

【网络分层模型】
 
每层的协议：
  
应用层：
FTP(21端口)：文件传输协议
SSH(22端口)：远程登录
TELNET(23端口)：远程登录
SMTP(25端口)：发送邮件
POP3(110端口)：接受邮件
HTTP(80端口)：超文本传输协议
DNS(53端口)：运行在UDP上，域名解析服务
传输层：建立了主机端对端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在俩个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。
网络层：路由器。本层通过IP寻址来建立俩个节点的连接，就是通常所说的IP层。（可以理解成对传输层的具体实现）选择合适的路由和交换节点，正确无误地按照地址传送给目的端的传输层。IP协议时Internet的基础。
数据链路层：交换机。将比特组合成字节，再将字节组合成帧，使用链路层地址（以太网使用MAC地址）来访问介质，并进行差错检测。又分为逻辑链路控制子层LLC，和媒体访问控制子层MAC。
物理层：实际最终信号的传输时通过物理层实现的。常用设备有集线器、中继器、调制解调器、网线、双绞线、同轴电缆。

【应用层：GET和POST区别】
GET、POST是HTTP的请求方法，是浏览器向服务器进行的请求
浏览器下，非Ajax的HTTP请求，浏览器用GET请求来获取一个html页面/图片/css/js等资源，用POST来提交一个<form>表单，并得到一个结果的网页。
GET和POST携带的数据格式有区别。
接口中的GET和POST：指浏览器的AJAX API， 或者IOS/Android的http client，java的commons-http client/okhttp或者时curl，postman之类的工具发出的GET和POST请求。
此时GET/POST不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种RPC协议使用）。没有浏览器中那么多限制，只要是符合HTTP格式的就可以发。
安全性：（经常会说GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但）是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。（这完全不是一个“是否容易在浏览器地址栏上看到“的问题。  ）
为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。（业界的）通行做法就是https——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立
【应用层：cookie和session区别】
数据存放位置不同。Cookie 数据存放在客户的浏览器上，session数据放在服务器上  |  安全程度不同。Cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session   |  性能使用程度不同。Session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面，应当使用cookie  |   数据存储大小不同。单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie，而session则储存于服务端，浏览器对其没有限制。
---Cookie的工作原理： Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话。HTTP协议是无状态协议，意味着服务器无法从连接上跟踪对话。因此，服务器给客户端们办法一个通行证，所有访问必须携带自己的通行证，这样服务器就能从通行证上确认客户身份了。
---Cookie具有不可跨域名性。

【应用层：HTTP HTTPS 区别】
HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。http协议是超文本传输协议，用于从万维网服务器传输文本到本地浏览器的传送协议，是基于tcp/ip通信协议来传输数据的
区别：
•	端口不同：HTTP使用的是80端口，HTTPs使用443端口
•	HTTP信息是明文传输，HTTPs运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全。
•	HTTPs由于加密解密会带来更大的CPU和内存开销。
•	HTTPs通信需要证书，一般需要向证书颁发机构(CA)购买
HTTPS连接过程：
•	客户端向服务器发送请求，同时发送客服端支持的一套加密规则（包括对称加密，非对称加密，摘要算法）。
•	服务收到以后，从中选择一组加密算法和HASH算法，并将自己的身份信息以证书的形式发回给浏览器。会向客户端发送认证信息，里面包括CA证书，数字签名，发送的信息会使用非对称加密。
•	客户端收到以后，会检查证书的可靠性，如果证书可信任，或者信任证书，就会生成一个随机密钥（对称加密用），和HASH算法，用服务器的公钥加密，发送给服务器。
•	服务器收到以后，会对HASH值
•	客户端会对HASH值进行验证，来检查数据的完整性，简历连接。
非对称加密算法用来加密密钥，对称加密用来加密数据，HASH算法用来检验完整性

【Python中HTTP常见响应状态码】
HTTP status code 用以表示网页服务器超文本传输协议响应状态的3位数字代码。
400：Bad Request | 401： unauthorized | 403: forbidden | 404：Not Found | 405：Method Not Allowed | 
2** ：成功 。200：ok
3**：重定向，表示要完成请求，需要进一步操作。301永久重定向，302暂时重定向
4**：请求错误，表示请求可能出错，放哀乐服务器的处理。
5**：服务器错误，服务器在尝试处理请求时发生呢不错误。可能是服务器本身的错误，而不是请求出错。500服务器内部错误，501服务不可用

【从输入网址到获得页面过程】

【传输层： 三次握手四次挥手机制及原因】three times handshake。
第一次握手：建立链接时，客户端发送syn包到服务器，并进入syn_sent状态，等待服务器确认。Syn：同步序列编号（synchronize sequence numbers）
第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个syn包（seq=k），即syn+ack包，此时服务器进入syn_secv状态。
第三次握手：客户端收到服务器的syn+ack包，向服务器发送确认包ack(ack=k+1),次饱发送完毕，客户端和服务器进入established（TCP连接成功）状态，完成三次握手。客户端与服务器开始传送数据。
为什么连接的时候是三次握手，关闭的时候却是四次握手？
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

为什么不能用两次握手进行连接？
答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

       现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
 
【传输层：TCP UDP区别】
 

什么时候选TCP？什么时候选UDP？：
           TCP                                               UDP
浏览器使用的：HTTP  HTTPs                                  TFTP 内部传输小文件协议
FlashFXP：FTP 文件传输协议                                  QQ语音
Outlook：POP，SMTP 邮件协议                            QQ视频
QQ文件传输

1. 如果数据要求完整，不允许任何错误发生
	应用层协议开放模式，例如http ftp ，唯一选择  TCP
	应用层协议封闭模式，例如游戏
	大量连接
•	长连接 / 短连接
•	少量数据传输：在2万连接以下使用TCP。其他   优先考虑udp
•	大流量数据传输：<1万连接-TCP。其他  优先udp可靠传输
	有限连接（通常小于2000，一般每服务器为几百到1000左右）
•	长连接： 除非当有数据实时性要求，优先考虑TCP，其他   udp
•	短连接：使用TCP可以减少代码的复杂性，增加广泛的移植性   TCP
2. 允许丢包，甚至可以乱序。
	对实时性要求比较高，例如voip（基于IP的语音传输） udp
	部分data允许丢包，部分data要求完整。部分有实时性要求，通常在游戏里，基本唯一能满足的选择是基于udp协议改造的udp多路可靠传输（同时支持不可靠模式），当然也可以同时使用tcp来传输要求完整的数据，但不建议，因为同时使用tcp和udp，会导致代码臃肿复杂度增加。   可靠udp
	部分数据优先传输，部分可丢弃数据在规定时效内传输，通常是 实时视频，在有限连接模式下，可以考虑TCP + UDP，最好选择可靠UDP   可靠udp
总结：//待

HTTP为什么选择TCP？
因为它传输的人容是不可以出现丢失，乱序等各种错误的，其次它需要跨平台实现。但同时，也承受了tcp带来的各种缺点，例如，缺少keep alive机制，tcp协议栈的实现问题引发的难以支持海量用户并发连接（只能通过dns等级别集群或者cdn来实现），协议太复杂导致很难模块化处理（解决方法：已经在nginx解决了，njinx通过模块化和对协议的分段处理机制，并引入消息机制，避免了多进程多线程的频繁切换）。总的来说，http应该选用tcp。
更古老的FTP为什么选择TCP？
因为它的每一个指令，或者文件传输的数据流，都需要保证可靠性。同时要求在各平台上广泛支持。它采用noop指令机制来处理tcp缺少keep alive机制带来的问题。 
POP3/SMTP为什么选择TCP？
常见的邮件协议，tcp是个好选择。
为什么TFTP使用udp协议？
Tftp是用于内部传输小文件的协议

为什么不能同时使用TCP和UDP？
因为会导致代码臃肿复杂度增加

TCP优点：国际通行了很多年，调用简单省心，兼容性是跨平台的。选了TCP以后，不管是windows还是linux，只要支持tcp/ip，就可以保证实现可靠连接和传输。
TCP缺点：每个tcp连接是一对一的，意味着美哦个连接都需要一个套接字socket，并且随时测试数据可读可写。连接数量达到一定程度时，性能会直线下降，主要是因为操作系统里用的指针链表。Tcp严重影响并发性能
UDP优点：udp最大的优点在于它的可塑性非常强，可以通过各种机制改造udp，比如实现可靠性传输，实现1对多传输，实现包和刘模式同时传输，优先发送，多路双向传输等等。udp是发射后不需要对方发送ack包进行确认。通常是不可靠传输，但可以在应用层对udp加上校验和序列号，做成可靠传输。

【传输层：TCP如何保证数据传输的可靠性】
•	数据包校验
•	对失序数据包重新排序（TCP报文具有序列号）
•	丢弃重复数据
•	应答机制：接受方收到数据之后，会发出一个确认
•	超时重发：发送方发出数据之后，启动一个定时器，超时未收到接受方的确认，则重新发送这个数据。
•	流量控制：确保接受端能够接受发送方的数据而不会缓冲区溢出

【传输层：TCP拥塞控制】
拥塞控制主要由4个算法组成：慢启动slow start、拥塞避免congestion voidance、快重传fast retransmit、快恢复fast recovery


后端开发---Python-Flask
Flask是Python阿红的一个微型的Web开发框架。
 
后端开发---Shell
【查看后台进程】
【给另一个电脑传输文件】 
【v查看top10】
【Linux删除文件】
【常用的几个linux命令】

【查看后台进程】--- 

【给另一个电脑传输文件】--- 

【v查看top10】--- 
10) Challenge: The most common first name for an MP is Andrew.
Write a shell pipeline which prints the 2nd most common MP first name.
It should print this first name and only this first name.

Q10 answer: cut -f1 -d":" parliament.txt|sed 's/ [^ ]*$//;s/.* //'|sort|uniq -c|sort -nr|head -3|sed 's/.* //'|head -2|tail -1

1) Write a shell pipeline to print how many classes there are.

Q1 answer: wc -l classes.txt|cut -c1-3

3) Write an egrep command that prints the words that contain four consecutive vowels?

Q3 answer: egrep "[aeiouAEIOU]{4}" dictionary.txt

【Linux删除文件】--- rm -f /usr/filename

【常用的几个linux命令】--- cd   ls   cat    rm    mkdir    cp    
Cat : 
•	cat filepath/filename   读取 filepath路径下filename文件内容
•	cat filename  读取当前路径下filename文件内容
rm : 
•	rm -rf path   删除path
•	rm test.txt    删除test.txt 文件
cp：
•	cp try.sh /usr/    复制当前路径下的try.sh 到 /usr/下


【列出访问次数前十的ip地址】--- 
 last | awk ‘{print$3}’| sort | uniq -c | sort -rn | head -10
last显示服务器上用户最近登陆信息
第三列为远程登录主机的ip

【v】--- 







后端开发---Perl
【v】--- 

【v】--- 

【v】--- 

【v】--- 

【v】--- 

【v】--- 

【v】--- 





后端开发---Java
【参数传递】--- Java是传值（传值和传引用，只不过引用就是内存地址，所以也是值）。Java里区分值和引用，是因为值存储在栈里，而引用对象在堆里。

【v】--- 

【v】--- 

【v】--- 

【v】--- 

【v】--- 

【v】--- 




后端开发---Redis
Redis通常被称为数据结构服务器，是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可给予内存可持久化的日志型、key-Value数据库，并提供多种语言的API。
【基本数据类型】--- 五种：string、hash、list、set、zset（sorted set 有序集合）

【特点】--- 
支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
不仅仅支持简单的key-value类型的数据，同时还提供list、set、zset、hash等数据结构的存储。
支持数据的备份，即master-slave模式的数据备份。

【v】--- 

【v】--- 

【v】--- 

【v】--- 
 
前端---JavaScript
【1．bind/apply/call区别】--- bind不会立即调用，其他俩个会立即调用。都是用来改变函数的this对象的指向的，第一个参数都是this要指向的对象，都可以利用后续参数传参。Call可以接收任意个数的参数，其中第一个必须是一个this对象，其余依次是所有的参数。

【2.原始值和引用值数据类型及区别】--- 基本数据类型：简单的数据段，引用数据类型：有多个值构成的对象。访问机制不同 / 声明变量时内存分配不同 / 复制变量时不同
基本数据类型：b复制a的时候只是copy值，b的改变不会对a造成影响。常见数据类型有Number String Boolean Null Undefined。
引用值数据类型：也就是对象类型Object type，比如Object、Array、Function、Data等。是保存在堆内存中的对象。当Obj2 = Obj1时，复制的是引用地址，Obj2改变时改变的是引用地址对应的堆内存，Obj1也被改变了


【3.判断数据类型】--- typeof、instanceof、Object.prototype.toString.call()、constructor。基本数据类型用typeof，引用数据类型用instanceof。万能方法toString()，不推荐使用constructor，因为这是可修改的、容易发生变化的。
基本数据类型有6个：Number、String、Boolean、Null、Undefined、symbol（ES6新的原始数据类型，代表独一无二的值）。引用类型1个Object，又包含array、function、object。

【4.类数组和数组/转换/区别】--- 区别：有length属性，最主要的是类数组对象不能调用数组原型上的方法，像xx.push()  xx.slice()  xx.indexOf() 等等。
转换：Array.prototype.slice.call(ArrayLike)   /  Array.from(ArrayLike)

【5.数组的常见API】--- 转换数组到字符串toString()、用数组的元素组成字符串join()、合并数组concat()、删除数组的最后一个元素pop()、数组的末尾添加新的元素push()、从一个数组中选择元素slice()、数组排序sort()、删除数组的第一个元素shift()、将一个数组中的元素的顺序反转排序reverse()、在数组的开头添加新元素unshift()、在数组的第2位置添加一个元素splice()
 
【6.new的原理】--- new创建一个新对象，将构造函数的作用域赋给新对象，执行构造函数中的代码（为新对象添加属性），返回新对象。执行时会在对象中执行，真正实例化一个对象，这个实例对象继承了原对象的属性和方法。New实现了JavaScript中的继承。
实际执行时：
new Person(20) = {
var obj = {};
obj.__proto__ = Person.prototype;
var result = Person.call(obj,20);
return typeof result === ‘object’? result:obj;
}
先创建了一个新的对象obj{}，再把这个对象的__proto__指向Person的原型对象prototype。


【7.如何正确判断this】--- 首先应该判断出函数的调用栈信息。1，隐式绑定，当一个函数拥有上下文对象时，该函数的this指向离函数最近的上下文对象。2，显式绑定，即用bind、call、apply来调用函数，可以为函数绑定一个值。3，使用new时，先会创建一个新的对象，如果没有return对象，就 return这个新对象。4，默认绑定，如果一个函数的调用方式匹配不了以上的三种方式，就会采用默认情况。 优先级：new>显式绑定>隐式绑定>默认绑定

【8.闭包及其作用】--- 

【9.原型和原型链】--- 所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。
JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。
添加属性：有的时候我们想要在所有已经存在的对象添加新的属性或方法。另外，有时候我们想要在对象的构造函数中添加属性或方法。使用 prototype 属性就可以给对象的构造函数添加新的属性。


【10.prototype与__proto__的关系与区别】--- 
1.	__proto__ 和constructor属性是对象所独有的
2.	prototype属性是函数所独有的，函数也是一种对象。任何函数在创建时都会默认同时创建该函数的prototype对象。
3.	__proto__属性的作用：当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就回去它的__proto__属性所指向的那个对象（父对象）里找，
 
判断属性时存在实例对象中，还是原型对象中：
person1.hasOwnProperty(“name”)   // true

【11.深拷贝 浅拷贝】--- 

【12.防抖和节流】--- 

【13.作用域和作用域链、执行期上下文】--- 

【14.DOM常见的操作方式】--- 

【15.Array.sort()方法与实现机制】--- 

【16.Ajax的请求过程】--- 

【17.JS的垃圾回收机制】--- 

【18.String、Array和Math方法】--- 

【19.addEventListener和onClick()区别】--- 

【20.new和Object.create的区别】--- 

【21.DOM的location对象】--- 

【22.浏览器从输入URL到页面渲染的整个流程】--- 

【23.浏览器的回流Reflow和重绘Repaints】--- 

【24.setTimeout用作倒计时为何会产生误差】--- 

【25.JavaScript中的arguments】--- 

【26.EventLoop事件循环】--- 

【27.BOM属性对象方法】--- 

【28.JS的map()和reduce()方法】--- 

【29.函数柯里化及其通用封装】--- 

【30.”==”和”===”区别】--- 



【跨域、同源策略及跨域实现方式和原理】--- 


【跨域】--- 跨域是浏览器从一个域名的网页去请求另一个域名的资源时，域名，端口，协议任一不同，都是跨域。它是由浏览器的基于安全限制施加的同源策略造成的。                         解决跨域方法： 1，JSONP    2，使用代理server，如Nginx。 3，服务端设置Header            4，CORS（跨资源共享cross-origin resource sharing）
1 JSONP 只能发get请求，本质上script加载资源就是get
2 Nginx：  使用80端口，当用户发送localhost：80/ 时会被nginx转发到    
http://localhost:81服务。当界面请求端口数据时，只要以/apis为开头时，就会被nginx转   
发到后端接口服务器上。
3服务端设置Header：Access-Control-Allow-Origin /  Access-Control-Allow-  Method:POST,GET 
4 CORS：浏览器将cors请求分成俩类，简单请求（simple request）/ 非简单请求（not- 
so-simple request）。

【JS继承】--- JS 实现继承的方法：1，对象冒充。 2，call方式。3，apply方式。4，原型链方式（prototype）。5，call 原型链混合方式。
Call方式缺点：实例不是父类的实例，只是子类的 / 只能继承父类的属性和方法，不能继承父类原型属性和方法。
原型链缺点：无法多继承 / 创建子类实例时，无法向父构造函数传参。

【JS】【Promise.js】--- Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。    特点：对象的状态不受外界影响，有3种状态 Pending进行中 resolved已完成  rejected已失败 / 一旦状态改变，就不会再变，任何时候都可以得到这个结果。               缺点： 无法中途取消，一旦建立立即执行 / 处于Pending状态时，无法得知目前进展到哪一个阶段 / 如果不设置回调函数，Promise内部跑出的错误不会反应到外部。                                       基本API ： 1，new Promise  2, PromiseObj.then(resolveFn,rejectFn)  3, Promise.all()  4, PromiseObj.catch()  5, PromiseObj.resolve()   6, Promise.reject()


【JS】【vue】--- 一套用于构建用户界面的渐进式JavaScript框架。Vue被设计成可以自底向上逐层应用。Vue核心库只关注视图层，方便与第三方库或既有项目整合。同时vue.js也能完美地驱动复杂的单页应用。



 
前端---HTML/CSS

前端---React
用于构建用户界面的JS库

 
概念
【面向对象】---(Object Oriented Programming，OOP)的三大特点（封装，继承，多态）缺一不可。主要有Smalltalk、Eiffel、C++、Java、PHP等。
	
【DFS，BFS】--- 深度优先搜索（适合？），广度优先搜索（适合最小路径）

【MongoDB】--- MongoDB是一个基于分布式文件存储 [1]  的数据库。由C++语言编写。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。特点：高性能，易部署，易使用。模式自由（schema-free）。不适用：传统的商业智能应用/复杂的跨文档级联查询

【RDBMS】--- 关系型数据库
【JS】【Node.js】--- Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。Node是一个让JavaScript运行在服务端的开发平台。 

【Python 继承】--- class ，可重写 / 子类想调用父类的方法，可以用super（）/ 如果父类方法是私有属性方法，eg def __heshui(self) ，其实编译器把这个方法的名字改成了_Animal__heshui(), 可以强制调用。 


【JS】【Promise.js】--- Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。    特点：对象的状态不受外界影响，有3种状态 Pending进行中 resolved已完成  rejected已失败 / 一旦状态改变，就不会再变，任何时候都可以得到这个结果。               缺点： 无法中途取消，一旦建立立即执行 / 处于Pending状态时，无法得知目前进展到哪一个阶段 / 如果不设置回调函数，Promise内部跑出的错误不会反应到外部。                                       基本API ： 1，new Promise  2, PromiseObj.then(resolveFn,rejectFn)  3, Promise.all()  4, PromiseObj.catch()  5, PromiseObj.resolve()   6, Promise.reject()


【JS】【vue】--- 一套用于构建用户界面的渐进式JavaScript框架。Vue被设计成可以自底向上逐层应用。Vue核心库只关注视图层，方便与第三方库或既有项目整合。同时vue.js也能完美地驱动复杂的单页应用。

【API】--- Application Programming Interface，应用程序接口 是一些预先定义的函数。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。
每一个对象都有API---这是一组公共方法和属性，对象可以用它来与应用中的其他对象进行交互。


【Restful / flask】--- REST(Representational State Transfer)是一种架构风格，表述了网络中客户端于服务端的一种交互。REST架构就是为了HTTP协议设计的。RESTful web services的核心概念是管理资源。资源是由URIs来表示，客户端使用HTTP当中的'POST,GET, PUT, DELETE'等方法发送请求到服务器，改变相应的资源状态。
 
 

【Ajax】--- “Asynchronous Javascript And XML”（异步 JavaScript 和 XML）。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。


【RAM】--- Ramdom Access Memory

 


